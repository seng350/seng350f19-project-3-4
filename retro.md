# Milestone 6 Looking Back
Team 3-4
### What we learned
SENG 350 served as an introduction to architecting an application and building it based on that initial architectural design. Our group learned several architectural approaches such as Model-View-Controller, and architectural views such as Allocation, Component and Connector, and Modular. GradeAchiever’s architecture  made use of a Model-View-Controller design to create this  web application that provided students with recommendations on how many hours they should study to get their desired grades. 

While designing the application, we learnt to make use of deployment tools such as docker, back-end server infrastructure software such as node and many node libraries. Additionally, we learnt how to use GitHub and the CI functionality it offered through Travis for running tests and setting up a build as well as husky for pre-commit verification of code quality. We learnt about software quality metrics, and tools for verifying them such as BetterCodeHub, SonarQube, and TSLint. These testing tools were used frequently throughout our design process, and in particular, analysing the cohesion and coupling statistics assisted us with refactoring our code.

Another major component of the project work for this course was learning to effectively work with asynchronous functions - specifically while dealing with database connections. Any access to the database had to be done in an asynchronous operation, which required us to learn not only to deal with management tools such as promises and async/await, but also effectively managing errors by catching rejected promise objects --functionality offered by promises. While this was probably one of the most frustrating things to learn to understand and utilize, it was probably also one of the most helpful skills that we can continue to use in our careers.

One major component of this project was learning TypeScript. For most of us, our previous JavaScript knowledge was sufficient in starting this project, but needed to be supplemented with the nuances of TypeScript. There are many small functionalities in JavaScript that either do not exist or do not work the same in Typescript because of its typing. Additionally, testing using Jest was already new for us and was made more complicated by the syntax required for TypeScript.

Finally, our group learnt to deal with HTTP Requests and how to use routing. Express routed requests coming in from the front-end to the back-end, and responded to them by rendering a different page. Our team learnt to parse request objects and populate response objects, in some cases asynchronously, which resulted in our group gaining some full-stack experience.

Overall, this course gave our team experience in developing a web application all the way from the initial architecture and planning stages to actually seeing the architecture come to life in the form of a final product.
### How the design can be improved
Throughout this project, we made a number of improvements to our original software architecture design. This included expanding the controllers to further modularize the application and adding a model specifically for the admin users. Looking back on our final design, there are still a number of changes that should be made to improve the current structure, but if we could, we would probably redesign the entire app itself now that we have a better understanding of what works and what doesn’t.

Specific design improvements that we would make would be to further change the dbclient. Currently, the dbclient connects to the database every single time we need to access the database; on every call to our base model, it used a connect method in our dbclient which created a new unique connection to the database. Rewriting our dbclient to give it the functionality to close connections, clear tables, and to only make a single connection to the database would be high on the priority list for future additions. 

Additionally, throughout the system the concept of classes in order to separate functionality should have been used. However, in the implementation, our group never really took advantage of what classes are for, which is storing stateful information. Ideally, we would have a class which has a bunch of fields and important information we would instantiate upon creating an instance of it. The application could instead have made use of files full of functions which executed the desired functionality, instead of creating new controllers or models which have functionality stored inside them. It just added unnecessary complexity for no technical benefit.

Beyond the issues we had with the dbclient, our implementation of the design often failed to match our initial design, especially with regards to the goals we set out with for low-coupling and high-cohesion. Our routes often interacted with multiple controllers, as routing was not initially planned out in the architecture, which caused them to be far too highly coupled and often have lower than desired cohesion. 

Aside from routing, our design inherently had a very closely coupled course controller and gradable item controller. This resulted in much of the functionality related to gradable items, such as adding or removing them, being implemented entirely in the course controller. And while this was presented in our original design, doing this made it so that the course controller needed to interact directly with the gradable item controller, which resulted in too much coupling. To solve design challenges like these might require some level of re-architecting and rethinking our current design.
### What we could do better
Starting with the first milestone, there were things that could have gone better in our project. We had QASs that turned out not to be real QASs for the problems our app was supposed to solve. This resulted in us having less than seven quality attributes and made our design less focused and structured. Our preparation for milestone 5 caused major errors with the software. We tried to do a major code refactor right before the demo, and the website did not work as well as it would have if we hadn’t.

Throughout the project, our group lacked organized project management. We never went through any traditional method of managing the project using sprints or a ticketing system. We sometimes made a list of parts of the current project milestone and arbitrarily assigned the parts to people. Additionally, our scheduling was very erratic; sometimes we set deadlines for each piece a member was assigned, and sometimes we just required everything to be done before the deadline. Improving the organization and project management are at the top of the list for things that we wish we did better.

Specifically, we had too many instances of leaving work until the day before the milestone was due. If we were to redo the project, we would set internal deadlines to be a day or two before the actual due-date to ensure time to cleanup any code errors and do any necessary refactoring. 

Another side-effect of our haphazard scheduling was long periods of time where no work was getting done. Because our meetings often happened a week or two before the milestone, and we did not set enough immediate milestones, we sometimes went up to two-weeks without any code being written or refactored; this naturally resulted in very little time remaining for the actual refactoring effort. 

